define(["react","@variousjs/various"],function(e,t){return function(){"use strict";var r={220:function(e){e.exports=t},959:function(t){t.exports=e}},n={};function o(e){var t=n[e];if(void 0!==t)return t.exports;var a=n[e]={exports:{}};return r[e](a,a.exports,o),a.exports}o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,{a:t}),t},o.d=function(e,t){for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var a={};o.r(a),o.d(a,{default:function(){return c}});var l=o(959),u=o.n(l);const i=(0,o(220).createComponent)({name:"aves"});var c={store:{},Root:()=>{const e=(0,l.useRef)(null);return u().createElement(u().Fragment,null,u().createElement("div",{style:{marginBottom:20}},"这段文本选中时候不应该弹出浮窗"),u().createElement(i,{className:"aves",$ref:e,popup:({text:t})=>u().createElement("div",{style:{background:"#fff",padding:"3px 8px",fontSize:14,border:"1px solid #e5e5e5",boxShadow:"0px 4px 8px 0px rgba(31, 35, 41, 0.1)",borderRadius:4}},u().createElement("span",{style:{cursor:"pointer"},onClick:()=>{navigator.clipboard.writeText(t||""),e.current?.hidePopup()}},"复制"))},u().createElement("h3",null,"中间件"),u().createElement("div",{className:"text",style:{height:1e3}},"空格     情况 Floating UI 还提供了中间件的概念，就是在调用 computePosition 之后，then 之前运行的一段代码，可以改变浮动元素的定位和行为。 中间件是实现除了基本定位功能之外的其他功能统一的方式。 Floating UI 提供了下面几个中间件",u().createElement("p",null,"另外一段文字情况"))))},Fallback:function(){return u().createElement("p",null,"loading...")},ErrorFallback:({$reload:e,$error:t})=>u().createElement(u().Fragment,null,u().createElement("h3",null,`[${t.type}]: ${t.message||"组件错误"}`),u().createElement("button",{onClick:e},"刷新")),actions:{}};return a}()});
//# sourceMappingURL=app.js.map